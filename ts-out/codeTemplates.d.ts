export declare const controllerTemplate = "\nimport { createClient } from \"redis\";\nimport WebSocket, { WebSocketServer } from \"ws\";\n//import models from \"../models/index.js\";\nimport models from \"../models/index.cjs\";\n\nimport auth from \"../authorization.cjs\";\n\nimport { v4 as uuidv4 } from \"uuid\";\nimport express, { Request, Response } from \"express\";\nimport crypto from \"crypto\";\n\nconst dbModels: Models = models;\nconst Group = dbModels.Group as GroupClass;\n\nconst PAIRWISE_API_HOST = process.env.PAIRWISE_API_HOST;\nconst PAIRWISE_USERNAME = process.env.PAIRWISE_USERNAME;\nconst PAIRWISE_PASSWORD = process.env.PAIRWISE_PASSWORD;\n\nconst defaultAuthHeader = {\n  \"Content-Type\": \"application/json\",\n  Authorization: `Basic ${Buffer.from(\n    `${PAIRWISE_USERNAME}:${PAIRWISE_PASSWORD}`\n  ).toString(\"base64\")}`,\n};\n\nconst defaultHeader = {\n  ...{ \"Content-Type\": \"application/json\" },\n  ...defaultAuthHeader,\n};\n\n//TODO: Do not duplicate from app.ts\ninterface YpRequest extends express.Request {\n  ypDomain?: any;\n  ypCommunity?: any;\n  sso?: any;\n  redisClient?: any;\n  user?: any;\n}\n\n//import auth from \"../authorization.js\";\nimport { AiHelper } from \"../active-citizen/engine/allOurIdeas/aiHelper.js\";\nimport { ExplainAnswersAssistant } from \"../active-citizen/engine/allOurIdeas/explainAnswersAssistant.js\";\nimport OpenAI from \"openai\";\nimport { lang } from \"moment\";\n\nexport class AllOurIdeasController {\n  public path = \"/api/allOurIdeas\";\n  public router = express.Router();\n  public wsClients: Map<string, WebSocket>;\n\n  constructor(wsClients: Map<string, WebSocket>) {\n    this.wsClients = wsClients;\n    this.initializeRoutes();\n  }\n\n  public async initializeRoutes() {\n    this.router.get(\n      \"/:groupId\",\n      auth.can(\"view group\"),\n      this.showEarl.bind(this)\n    );\n    this.router.post(\n      \"/:communityId/questions\",\n      auth.can(\"create group\"),\n      this.createQuestion.bind(this)\n    );\n    this.router.put(\n      \"/:communityId/generateIdeas\",\n      auth.can(\"create group\"),\n      this.generateIdeas.bind(this)\n    );\n\n    this.router.put(\n      \"/:groupId/llmAnswerExplain\",\n      auth.can(\"view group\"),\n      this.llmAnswerExplain.bind(this)\n    );\n\n    this.router.get(\n      \"/:communityId/choices/:questionId\",\n      auth.can(\"create group\"),\n      this.getChoices.bind(this)\n    );\n\n    this.router.get(\n      \"/:groupId/choices/:questionId/throughGroup\",\n      auth.can(\"view group\"),\n      this.getChoices.bind(this)\n    );\n\n    this.router.post(\n      \"/:groupId/questions/:questionId/prompts/:promptId/votes\",\n      auth.can(\"view group\"),\n      this.vote.bind(this)\n    );\n\n    this.router.post(\n      \"/:groupId/questions/:questionId/prompts/:promptId/skips\",\n      auth.can(\"view group\"),\n      this.skip.bind(this)\n    );\n\n    this.router.post(\n      \"/:groupId/questions/:questionId/addIdea\",\n      auth.can(\"view group\"),\n      this.addIdea.bind(this)\n    );\n\n    this.router.get(\n      \"/:groupId/questions/:wsClientSocketId/:analysisIndex/:analysisTypeIndex/analysis\",\n      auth.can(\"view group\"),\n      this.analysis.bind(this)\n    );\n\n    this.router.put(\n      \"/:communityId/questions/:questionId/choices/:choiceId\",\n      auth.can(\"create group\"),\n      this.updateCoiceData.bind(this)\n    );\n\n    this.router.put(\n      \"/:groupId/questions/:questionId/choices/:choiceId/throughGroup\",\n      auth.can(\"view group\"),\n      this.updateCoiceData.bind(this)\n    );\n\n    this.router.put(\n      \"/:communityId/questions/:questionId/choices/:choiceId/active\",\n      auth.can(\"create group\"),\n      this.updateActive.bind(this)\n    );\n\n    this.router.put(\n      \"/:communityId/questions/:questionId/name\",\n      auth.can(\"create group\"),\n      this.updateQuestionName.bind(this)\n    );\n\n    this.router.get(\n      \"/:groupId/content/:extraId/:questionId/translatedText\",\n      auth.can(\"view group\"),\n      this.getTranslatedText.bind(this)\n    );\n\n    this.router.get(\n      \"/:groupId/content/:extraId/translatedText\",\n      auth.can(\"view group\"),\n      this.getTranslatedText.bind(this)\n    );\n  }\n\n  async addIdea(req: Request, res: Response) {\n    const { newIdea, id } = req.body;\n    let choiceParams = {\n      visitor_identifier: req.session.id,\n      data: {\n        content: newIdea,\n        isGeneratingImage: undefined,\n      },\n      question_id: req.params.questionId,\n    };\n\n    //@ts-ignore\n    choiceParams[\"local_identifier\"] = req.user ? req.user.id : req.session.id;\n\n    console.log(`choiceParams: ${JSON.stringify(choiceParams)}`);\n\n    try {\n      const choiceResponse = await fetch(`${PAIRWISE_API_HOST}/choices.json`, {\n        method: \"POST\",\n        headers: defaultAuthHeader,\n        body: JSON.stringify(choiceParams),\n      });\n\n      if (!choiceResponse.ok) {\n        console.error(choiceResponse.statusText);\n        throw new Error(\"Choice creation failed.\");\n      }\n\n      const choice = (await choiceResponse.json()) as AoiChoiceData;\n\n      choice.data = JSON.parse(choice.data as any) as AoiAnswerToVoteOnData;\n\n      let flagged = false;\n      if (process.env.OPENAI_API_KEY) {\n        flagged = await this.getModerationFlag(newIdea);\n        if (flagged) {\n          await this.deactivateChoice(req, choice.id);\n          console.log(\"----------------------------------\");\n          console.log(`Flagged BY OPENAI: ${flagged}`);\n          console.log(\"----------------------------------\");\n        } else {\n          console.log(`Not flagged BY OPENAI: ${flagged}`);\n        }\n      }\n\n      // Implement email notification logic based on choice's active status\n\n      res.json({\n        active: choice.active,\n        flagged: flagged,\n        choice: choice,\n        choice_status: choice.active ? \"active\" : \"inactive\",\n        message: `You just submitted: ${escape(newIdea)}`, // Use a proper escape function\n      });\n    } catch (error) {\n      console.error(error);\n      res.status(500).json({ error: \"Addition of new idea failed\" });\n    }\n  }\n\n\n  public async getTranslatedText(req: Request, res: Response): Promise<void> {\n    try {\n      //@ts-ignore\n      models.AcTranslationCache.getTranslation(\n        req,\n        {},\n        function (error: string, translation: string) {\n          if (error) {\n            console.error(error);\n            res.status(500).send(\"A getTranslatedText error occurred\");\n          } else {\n            res.send(translation);\n          }\n        }\n      );\n    } catch (error) {\n      console.error(error);\n      res.status(500).send(\"A getTranslatedText error occurred\");\n    }\n  }\n}\n";
export declare const modelIndexTemplate = "\nimport { InitUser } from \"./user\";\nimport { InitProject } from \"./project\";\nimport { InitRole } from \"./role\";\nimport { InitRound } from \"./round\";\nimport { InitStage } from \"./stage\";\nimport { InitStory } from \"./story\";\nimport { InitMeeting } from \"./meeting\";\nimport { InitEmailCampaign } from \"./emailCampaign\";\nimport { InitSentEmail } from \"./sentEmail\";\nimport { InitIssue } from \"./issue\";\nimport { InitActionPlan } from \"./actionPlan\";\nimport { InitAction } from \"./action\";\nimport { InitScoreCard } from \"./scoreCard\";\nimport { InitComment } from \"./comment\";\nimport { InitProgressReport } from \"./progressReport\";\nimport { KeyObject } from \"crypto\";\nimport { InitTranslationCache } from \"./translationCache\";\nimport { InitRating } from \"./rating\";\n\nconst Sequelize = require(\"sequelize\");\n\nconst env = process.env.NODE_ENV || \"development\";\n\nlet sequelize;\n\nif (process.env.DATABASE_URL) {\n  sequelize = new Sequelize(process.env.DATABASE_URL, {\n    dialect: \"postgres\",\n    dialectOptions: {\n      ssl: {\n        rejectUnauthorized: false,\n      },\n    },\n  });\n} else {\n  const config = require(`${__dirname}/../../config/config.json`)[env];\n  sequelize = new Sequelize(\n    config.database,\n    config.username,\n    config.password,\n    config\n  );\n}\n\nexport const models = {\n  sequelize,\n  Sequelize,\n  Role: InitRole(sequelize),\n  Project: InitProject(sequelize),\n  User: InitUser(sequelize),\n  Round: InitRound(sequelize),\n  Stage: InitStage(sequelize),\n  Story: InitStory(sequelize),\n  Meeting: InitMeeting(sequelize),\n  EmailCampaign: InitEmailCampaign(sequelize),\n  SentEmail: InitSentEmail(sequelize),\n  Issue: InitIssue(sequelize),\n  ActionPlan: InitActionPlan(sequelize),\n  Action: InitAction(sequelize),\n  ScoreCard: InitScoreCard(sequelize),\n  Comment: InitComment(sequelize),\n  ProgressReport: InitProgressReport(sequelize),\n  TranslationCache: InitTranslationCache(sequelize),\n  Rating: InitRating(sequelize),\n};\n\n// Associations\n\n// Project\nmodels.Project.hasMany(models.Round, {\n  sourceKey: \"id\",\n  foreignKey: \"projectId\",\n  as: \"Rounds\",\n});\n\n//models.Project.belongsTo(models.User,  { as: 'User', foreignKey: 'userId' });\n\nmodels.Project.belongsToMany(models.User, {\n  through: \"ProjectUsers\",\n});\n\n// User\n/*models.User.hasMany(models.Project, {\n  sourceKey: \"id\",\n  foreignKey: \"userId\",\n  as: \"Projects\"\n});*/\n\nmodels.User.belongsToMany(models.Role, {\n  through: \"UserRoles\",\n});\n\nmodels.User.belongsToMany(models.Project, {\n  through: \"ProjectUsers\",\n});\n\nmodels.User.hasMany(models.Role, {\n  sourceKey: \"id\",\n  foreignKey: \"userId\",\n  as: \"UserRoles\",\n});\n\nmodels.User.hasMany(models.Comment, {\n  sourceKey: \"id\",\n  foreignKey: \"userId\",\n});\n\n// Round\nmodels.Round.belongsTo(models.Project, {\n  as: \"Project\",\n  foreignKey: \"projectId\",\n});\n\nmodels.Round.hasMany(models.Meeting, {\n  sourceKey: \"id\",\n  foreignKey: \"roundId\",\n  as: \"Meetings\",\n});\n\nmodels.Round.hasMany(models.Issue, {\n  sourceKey: \"id\",\n  foreignKey: \"roundId\",\n  as: \"Issues\",\n});\n\nmodels.Round.hasMany(models.Rating, {\n  sourceKey: \"id\",\n  foreignKey: \"roundId\",\n  as: \"Ratings\",\n});\n\n// Stage\nmodels.Stage.belongsTo(models.Round, { as: \"Round\", foreignKey: \"roundId\" });\n\n// Story\nmodels.Stage.belongsTo(models.Project, {\n  as: \"Project\",\n  foreignKey: \"projectId\",\n});\n\nmodels.Story.belongsToMany(models.EmailCampaign, {\n  through: \"EmailCampaignStories\",\n});\n\nmodels.Story.belongsToMany(models.Stage, {\n  through: \"StageStories\",\n});\n\n// Meeting\nmodels.Meeting.belongsTo(models.Round, { as: \"Round\", foreignKey: \"roundId\" });\n\n// EmailCampaign\nmodels.EmailCampaign.hasMany(models.SentEmail, {\n  sourceKey: \"id\",\n  foreignKey: \"emailCampaignId\",\n  as: \"SentEmails\",\n});\n\n// SentEmail\nmodels.SentEmail.belongsTo(models.EmailCampaign, {\n  as: \"EmailCampaign\",\n  foreignKey: \"emailCampaignId\",\n});\n\n// Issue\nmodels.Issue.belongsTo(models.Round, { as: \"Round\", foreignKey: \"roundId\" });\n\nmodels.Issue.belongsToMany(models.ScoreCard, {\n  through: \"ScoreCardIssues\",\n});\n\nmodels.Issue.hasMany(models.Comment, {\n  sourceKey: \"id\",\n  foreignKey: \"issueId\",\n});\n\nmodels.Issue.hasMany(models.Action, {\n  sourceKey: \"id\",\n  foreignKey: \"issueId\",\n});\n\nmodels.Issue.hasMany(models.Rating, {\n  sourceKey: \"id\",\n  foreignKey: \"issueId\",\n  as: \"Ratings\"\n});\n\n// ActionPlan\n/*models.ActionPlan.hasMany(models.Action, {\n  sourceKey: \"id\",\n  foreignKey: \"actionPlanId\",\n  as: \"Actions\",\n});*/\n\n// Action\nmodels.Action.belongsTo(models.Issue, { as: \"Issue\", foreignKey: \"issueId\" });\n\n/*models.Action.belongsTo(models.ActionPlan, {\n  as: \"ActionPlan\",\n  foreignKey: \"actionPlanId\",\n});*/\n\n// ScoreCard\n\n// Comment\n\nmodels.Comment.belongsTo(models.Issue, { as: \"Issue\", foreignKey: \"issueId\" });\nmodels.Comment.belongsTo(models.Action, {\n  as: \"Action\",\n  foreignKey: \"actionId\",\n});\nmodels.Comment.belongsTo(models.User, { as: \"User\", foreignKey: \"userId\" });\n\n// ProgressReport\nmodels.ProgressReport.belongsTo(models.Action, {\n  as: \"Action\",\n  foreignKey: \"actionId\",\n});\n\n// Rating\nmodels.Rating.belongsTo(models.Issue, { as: \"Issue\", foreignKey: \"issueId\" });\n\nconst force = process.env.FORCE_CSC_DB_SYNC ? true : false;\n\nif (force) {\n  sequelize.sync({ force }).then(async ()=>{}).catch((error: any) => {\n}\n";
export declare const modelTemplate = "\nimport {\n  Sequelize,\n  Model,\n  ModelDefined,\n  DataTypes,\n  HasManyGetAssociationsMixin,\n  HasManyAddAssociationMixin,\n  HasManyHasAssociationMixin,\n  BelongsToManyAddAssociationMixin,\n  Association,\n  HasManyCountAssociationsMixin,\n  HasManyCreateAssociationMixin,\n  Optional,\n  BelongsToManyGetAssociationsMixinOptions,\n  BelongsToManyGetAssociationsMixin,\n} from \"sequelize\";\n\nimport express from \"express\";\n\nimport { User } from \"./user\";\nimport { Round } from \"./round\";\nimport { models } from \".\";\n\ninterface ProjectCreationAttributes extends Optional<ProjectAttributes, \"id\"> {}\n\nexport class Project\n  extends Model<ProjectAttributes, ProjectCreationAttributes>\n  implements ProjectAttributes {\n  public id!: number;\n  public userId!: number;\n  public name!: string;\n  public description!: string;\n  public language!: string | null;\n  public publicData!: ProjectPublicDataAttributes | null;\n\n  // timestamps!\n  public readonly createdAt!: Date;\n  public readonly updatedAt!: Date;\n\n  // Since TS cannot determine model association at compile time\n  // we have to declare them here purely virtually\n  public getRound!: HasManyGetAssociationsMixin<Round>; // Note the null assertions!\n  public addRound!: HasManyAddAssociationMixin<Round, number>;\n\n  public getUser!: BelongsToManyGetAssociationsMixin<User>; // Note the null assertions!\n  public addUser!: BelongsToManyAddAssociationMixin<User, number>;\n\n  // You can also pre-declare possible inclusions, these will only be populated if you\n  // actively include a relation.\n  public readonly Rounds?: Round[]; // Note this is optional since it's only populated when explicitly requested in code\n  public readonly Users?: User[]; // Note this is optional since it's only populated when explicitly requested in code\n\n  public static associations: {\n    Rounds: Association<Project, Round>,\n    Users: Association<Project, User>\n  };\n\n  public static async addParticipants(body: ParticipantsUploadAttributes, res: express.Response) {\n    const lines = body.participants.split(\"\n\");\n    const roleId = body.roleId+1;\n    const language = body.language;\n    const projectId = body.projectId;\n\n    try {\n      const role = await models.Role.findOne({\n        where: {\n          id: roleId\n        }\n      })\n      for (let i=0; i<lines.length;i++) {\n        if (lines[i].length>10) {\n          const splitLine = lines[i].split(\",\")\n          const email = splitLine[0];\n          const name = splitLine[1];\n          const user = await models.User.create({\n            name,\n            email,\n            language,\n            encrypedPassword: \"12345\"\n          });\n\n          await user.addRole(role!);\n\n          console.error(\"pr \"+projectId);\n\n          const project = await models.Project.findOne({\n            where: {\n              id: projectId\n            }\n          })\n\n          if (!project) {\n            res.sendStatus(404);\n            break;\n          } else {\n            user.addProject(project);\n          }\n        }\n      }\n\n      res.sendStatus(200);\n    } catch(error) {\n      console.error(error);\n      res.sendStatus(500);\n    }\n  }\n}\n\nexport const InitProject = (sequelize: Sequelize) => {\n  Project.init(\n    {\n      id: {\n        type: DataTypes.INTEGER,\n        autoIncrement: true,\n        primaryKey: true,\n      },\n      name: {\n        type: new DataTypes.STRING(256),\n        allowNull: false,\n      },\n      description: {\n        type: DataTypes.STRING,\n        allowNull: false,\n      },\n      language: {\n        type: new DataTypes.STRING(10),\n        allowNull: true,\n      },\n      userId: {\n        type: DataTypes.INTEGER,\n        allowNull: false,\n      },\n      publicData: {\n        type: DataTypes.JSONB,\n        allowNull: true,\n      },\n      createdAt: {\n        type: DataTypes.DATE,\n        allowNull: false,\n      },\n      updatedAt: {\n        type: DataTypes.DATE,\n        allowNull: false,\n      },\n    },\n    {\n      timestamps: true,\n      paranoid: true,\n      tableName: \"projects\",\n      sequelize,\n    }\n  );\n\n  return Project\n};\n\n";
export declare const classTemplate = "\nimport { jsonrepair } from \"jsonrepair\";\nimport { OpenAI } from \"openai\";\nimport { YpLanguages } from \"../../utils/ypLanguages.js\";\nimport { parse } from \"path\";\nimport { Translate } from \"aws-sdk\";\nimport * as cheerio from \"cheerio\";\nimport { Cheerio, Element } from \"cheerio\";\n\nexport class YpLlmTranslation {\n  openaiClient: OpenAI;\n  modelName = \"gpt-4-0125-preview\";\n  maxTokens = 4000;\n  temperature = 0.0;\n\n  constructor() {\n    this.openaiClient = new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY,\n    });\n  }\n\n  extractHtmlStrings(html: string): string[] {\n    const $ = cheerio.load(html);\n    const strings: string[] = [];\n\n    // Function to recursively extract text from all elements\n    function recursivelyExtractText(elements: Cheerio<Element>): void {\n      elements.each((index, element) => {\n        if (element.tagName === 'script') {\n          return;\n        }\n        // Check if the element itself contains a direct text node\n        $(element)\n          .contents()\n          .filter((idx, content) => {\n            // Ensure that content is a text node and not empty\n            return (\n              content.type === \"text\" && $(content).text().trim().length > 0\n            );\n          })\n          .each((idx, content) => {\n            const text = $(content).text().trim();\n            if (text) {\n              strings.push(text);\n            }\n          });\n\n        // Recursively extract text from child elements\n        recursivelyExtractText($(element).children());\n      });\n    }\n\n    // Start the recursive text extraction from the body or root of the document\n    recursivelyExtractText($(\"body\").length ? $(\"body\") : $.root());\n\n    // Attributes with user-facing text\n    $(\"input[placeholder], input[value]\").each((index, element) => {\n      const placeholder = $(element).attr(\"placeholder\");\n      if (placeholder && placeholder.trim().length > 0) {\n        strings.push(placeholder.trim());\n      }\n      const value = $(element).attr(\"value\");\n      if (\n        value &&\n        $(element).attr(\"type\") !== \"text\" &&\n        value.trim().length > 0\n      ) {\n        strings.push(value.trim());\n      }\n    });\n\n    // Return unique non-empty strings\n    return [...new Set(strings)];\n  }\n\n   ...\n\n  renderOneTranslationSystemMessage() {\n    return `You are a helpful answer translation assistant that knows all the world languages.\n      INPUTS:\n      The user will tell us the Language to translate to.\n      The user will give you a string to be translated.\n\n      OUTPUT:\n      You will output only the translated string.\n\n      INSTRUCTIONS:\n      Keep it similar length as the original text.\n      Translate the tone of the original language also.\n      NEVER output anything else than the translated string.`;\n  }\n\n  renderListTranslationSystemMessage() {\n    return `You are a helpful translation assistant that knows all the world languages.\n\n      INPUTS:\n      The user will tell us the Language to translate to.\n\n      You will get JSON with an array of strings to translate:\n      [\n        \"string\",\n        ...\n      ]\n\n      OUTPUT:\n      You will output JSON string array in the same order as the input array.\n      [\n        \"string\",\n        ...\n      ]\n\n\n      INSTRUCTIONS:\n      Do not translate brand names including ours: All Our Ideas and Your Priorities except it is a well known brand in the target language.\n      Always output only a JSON string array.`;\n  }\n\n  // User messages\n\n  renderOneTranslationUserMessage(language: string, stringToTranslate: string) {\n    return `Language to translate to: ${language}\n      String to translate:\n      ${stringToTranslate}\n      Your translated string:`;\n  }\n\n  renderListTranslationUserMessage(\n    language: string,\n    textsToTranslate: Array<string>\n  ) {\n    return `Language to translate to: ${language}\n      Texts to translate in JSON string array:\n      ${JSON.stringify(textsToTranslate, null, 2)}\n\n      Your ${language} translations as JSON string array:`;\n  }\n\n  renderAnswersUserMessage(\n    language: string,\n    question: string,\n    answer: AoiTranslationAnswerInData\n  ) {\n    return `Language to translate to: ${language}\n\n    Question:\n    ${question}\n\n    Answers to translate in JSON Input:\n    ${JSON.stringify(answer, null, 2)}\n\n    Your ${language} JSON output:`;\n  }\n\n  renderQuestionUserMessage(\n    language: string,\n    question: string,\n    questionData: AoiTranslationQuestionInData\n  ) {\n    return `Language to translate to: ${language}\n\n    Question to translate in JSON format:\n    ${JSON.stringify(questionData, null, 2)}\n\n    Your ${language} JSON output:`;\n  }\n\n  async getModerationFlag(content: string): Promise<boolean> {\n    const moderationResponse = await this.openaiClient.moderations.create({\n      input: content,\n    });\n    console.log(\"Moderation response:\", moderationResponse);\n    const flagged = moderationResponse.results[0].flagged;\n    return flagged;\n  }\n\n  async getHtmlTranslation(\n    languageIsoCode: string,\n    htmlToTranslate: string\n  ): Promise<string | null | undefined> {\n    try {\n      const originalStrings = this.extractHtmlStrings(htmlToTranslate);\n      if (originalStrings.length === 0) {\n        console.warn(\"No HTML strings to translate\");\n        return htmlToTranslate;\n      }\n\n      const batchSize = 10;\n      const translatedStrings: string[] = [];\n      for (let i = 0; i < originalStrings.length; i += batchSize) {\n        const batch = originalStrings.slice(i, i + batchSize);\n        const translatedBatch = await this.getListTranslation(\n          languageIsoCode,\n          batch\n        );\n        if (translatedBatch) {\n          translatedStrings.push(...translatedBatch);\n        } else {\n          console.error(\"Failed to translate batch:\", batch);\n          return undefined;\n        }\n      }\n\n      // Replace original strings in HTML with their translations\n      const translatedHtml = this.replaceHtmlStrings(\n        htmlToTranslate,\n        originalStrings,\n        translatedStrings\n      );\n      return translatedHtml;\n    } catch (error) {\n      console.error(\"Error in getHtmlTranslation:\", error);\n      return undefined;\n    }\n  }\n\n  async getOneTranslation(\n    languageIsoCode: string,\n    stringToTranslate: string\n  ): Promise<string | null | undefined> {\n    try {\n      console.log(`getOneTranslation: ${stringToTranslate} ${languageIsoCode}`);\n      const languageName =\n        YpLanguages.getEnglishName(languageIsoCode) || languageIsoCode;\n      return (await this.callSimpleLlm(\n        languageName,\n        stringToTranslate,\n        false,\n        this.renderOneTranslationSystemMessage,\n        this.renderOneTranslationUserMessage\n      )) as string | null;\n    } catch (error) {\n      console.error(\"Error in getAnswerIdeas:\", error);\n      return undefined;\n    }\n  }\n\n  async getListTranslation(\n    languageIsoCode: string,\n    stringsToTranslate: string[]\n  ): Promise<string[] | null | undefined> {\n    try {\n      console.log(`getOneTranslation: ${languageIsoCode}`);\n      const languageName =\n        YpLanguages.getEnglishName(languageIsoCode) || languageIsoCode;\n      if (await this.getModerationFlag(stringsToTranslate.join(\" \"))) {\n        console.error(\"Flagged:\", stringsToTranslate);\n        return null;\n      } else {\n        return (await this.callSimpleLlm(\n          languageName,\n          stringsToTranslate,\n          true,\n          this.renderListTranslationSystemMessage,\n          this.renderListTranslationUserMessage\n        )) as string[] | null;\n      }\n    } catch (error) {\n      console.error(\"Error in getAnswerIdeas:\", error);\n      return undefined;\n    }\n  }\n\n  ...\n\n  async callSimpleLlm(\n    languageName: string,\n    toTranslate: string[] | string,\n    parseJson: boolean,\n    systemRenderer: Function,\n    userRenderer: Function\n  ): Promise<string | object | null | undefined> {\n    const messages = [\n      {\n        role: \"system\",\n        content: systemRenderer(),\n      },\n      {\n        role: \"user\",\n        content: userRenderer(languageName, toTranslate),\n      },\n    ] as any;\n\n    const maxRetries = 3;\n    let retries = 0;\n\n    let running = true;\n\n    while (running) {\n      try {\n        console.log(`Messages ${retries}:`, messages);\n        const results = await this.openaiClient.chat.completions.create({\n          model: this.modelName,\n          messages,\n          max_tokens: this.maxTokens,\n          temperature: this.temperature,\n        });\n\n        console.log(\"Results:\", results);\n        let llmOutput = results.choices[0].message.content;\n        console.log(\"Return text:\", llmOutput);\n        if (parseJson) {\n          if (llmOutput) {\n            llmOutput = llmOutput.replace(/```json/g, \"\");\n            llmOutput = llmOutput.replace(/```/g, \"\");\n            return JSON.parse(jsonrepair(llmOutput!));\n          } {\n            console.error(\"No content in response\");\n            return undefined;\n          }\n        } else {\n          return llmOutput;\n        }\n      } catch (error) {\n        console.error(\"Error in getChoiceTranslation:\", error);\n        retries++;\n        if (retries > maxRetries) {\n          running = false;\n          return undefined;\n        }\n      }\n    }\n  }\n\n  async callSchemaLlm(\n    jsonInSchema: string,\n    jsonOutSchema: string,\n    lengthInfo: string,\n    languageName: string,\n    question: string,\n    toTranslate:\n      | AoiTranslationAnswerInData\n      | AoiTranslationQuestionInData\n      | string[]\n      | string,\n    maxCharactersInTranslation: number | undefined,\n    systemRenderer: Function,\n    userRenderer: Function\n  ): Promise<string | null | undefined> {\n    console.log(\n      \"Call schema LLM:\",\n      jsonInSchema,\n      jsonOutSchema,\n      lengthInfo,\n      languageName,\n      question,\n      toTranslate,\n      maxCharactersInTranslation\n    );\n    const messages = [\n      {\n        role: \"system\",\n        content: this.renderSchemaSystemMessage(\n          jsonInSchema,\n          jsonOutSchema,\n          lengthInfo\n        ),\n      },\n      {\n        role: \"user\",\n        content: userRenderer(languageName, question, toTranslate),\n      },\n    ] as any;\n\n    const maxRetries = 5;\n    let retries = 0;\n\n    let running = true;\n\n    while (running) {\n      try {\n        console.log(`Messages ${retries}:`, messages);\n        const results = await this.openaiClient.chat.completions.create({\n          model: this.modelName,\n          messages,\n          max_tokens: this.maxTokens,\n          temperature: this.temperature,\n        });\n\n        console.log(\"Results:\", results);\n        let textJson = results.choices[0].message.content;\n        console.log(\"Text JSON:\", textJson);\n\n        if (textJson) {\n          textJson = textJson.replace(/```json/g, \"\");\n          textJson = textJson.replace(/```/g, \"\");\n          const translationData = JSON.parse(\n            jsonrepair(textJson)\n          ) as AoiTranslationAnswerOutData;\n          if (translationData && translationData.translatedContent) {\n            if (\n              maxCharactersInTranslation &&\n              translationData.translatedContent.length >\n                maxCharactersInTranslation\n            ) {\n              console.log(\n                \"Translation too long retrying:\",\n                translationData.translatedContent\n              );\n              messages[0].content = this.renderSchemaTryAgainSystemMessage(\n                jsonInSchema,\n                jsonOutSchema,\n                lengthInfo,\n                translationData.translatedContent\n              );\n\n              throw new Error(\"Translation too long\");\n            }\n            running = false;\n            console.log(\"Return text \" + translationData.translatedContent);\n            return translationData.translatedContent;\n          } else {\n            this.temperature = Math.random() * 0.99;\n            console.log(\n              \"No content in response. Temperature set to: \" + this.temperature\n            );\n            throw new Error(\"No content in response\");\n          }\n        } else {\n          this.temperature = Math.random() * 0.99;\n          console.log(\n            \"No content in response. Temperature set to:\" + this.temperature\n          );\n          throw new Error(\"No content in response\");\n        }\n      } catch (error) {\n        console.error(\"Error in callSchemaLlm:\", error);\n        retries++;\n        if (retries > maxRetries) {\n          running = false;\n          return undefined;\n        }\n      }\n    }\n  }\n}\n";
export declare const moduleTemplate = "\nimport * as bunyan from 'bunyan';\nimport PrettyStream from 'bunyan-prettystream';\n\nlet logger: bunyan;\n\nif (process.env.USE_BUNYAN_LOGGER && process.env.NODE_ENV !== 'production') {\n  const prettyStdOut = new PrettyStream();\n  prettyStdOut.pipe(process.stdout);\n\n  logger = bunyan.createLogger({\n    name: 'yrpri',\n    streams: [{\n      level: 'debug',\n      type: 'raw',\n      stream: prettyStdOut\n    }]\n  });\n} else {\n  if (process.env.USE_BUNYAN_LOGGER) {\n    logger = bunyan.createLogger({ name: \"your-priorities\" });\n  } else {\n    // If you don't want to use any logger, you can assign 'console' to 'logger'.\n    // However, you need to cast it to any as 'console' and 'bunyan' have different types.\n    logger = console as any;\n  }\n}\n\nexport default logger;\n";
//# sourceMappingURL=codeTemplates.d.ts.map